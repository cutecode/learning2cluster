
# TODO
# Requirements:
# - Output can be a 2D image
# - Output can be a 1D image
# - Allow different audio data types (spectrogram types; maybe use the AUdioHelper from VT2 as an argument for the audio data provider)
import numpy as np
from random import Random
from os import path
from time import time

from impl.data.image.image_data_provider import ImageDataProvider

from impl.data.misc.audio_helper import AudioHelper

from impl.misc.simple_file_cache import SimpleFileCache

class AudioDataProvider(ImageDataProvider):
    def __init__(self, data_dir=None, audio_helper=None, cache_directory=None, train_classes=None, validate_classes=None,
                 test_classes=None, window_width=100, return_1d_audio_data=False,
                 min_cluster_count=None, max_cluster_count=None, concat_audio_files_of_speaker=False,
                 minimum_snippets_per_cluster=1, return_equal_snippet_size=True):
        if audio_helper is None:
            audio_helper = AudioHelper()

        self.__rand = Random()
        self.__data = None
        self.__data_dir = data_dir
        self.__audio_helper = audio_helper
        self.__cache = None if cache_directory is None else SimpleFileCache(cache_directory, compression=True)
        self.__concat_audio_files_of_speaker = concat_audio_files_of_speaker

        # Window width may be a scalar or an array of possible intervals for the sizes, e.g.:
        # [(180, 200), (400, 420), ...]
        # The output shape will be the maximum possible window width
        self.__window_width = [(window_width, window_width)] if isinstance(window_width, int) else window_width

        # The minimum amount of snippets per cluster. For the "default" behaviour just 1 can be chosen.
        # In general it is possible to use a natural number. It is also possible to use a list with windows
        # widths where each cluster at least contains snippets with windows in the given interval. E.g.:
        # [(100, 200), (500, 550), ...]
        # This feature may be used to force a cluster to contains at least e.g. one small and one large element.
        self.__minimum_snippets_per_cluster = minimum_snippets_per_cluster

        # Should it be allowed that snippets which are generated by the __minimum_snippets_per_cluster setting
        # overlap? This setting is only used if "__concat_audio_files_of_speaker" is enabled
        self.__allow_minimum_snippets_overlap = False

        # The output length is the maximum possible snippet length
        self.__output_length = max(map(lambda r: r[1], self.__window_width + ([] if isinstance(self.__minimum_snippets_per_cluster, int) else self.__minimum_snippets_per_cluster)))

        # If "return_equal_snippet_size" is False different snippets may have different lengths
        self.__return_equal_snippet_size = return_equal_snippet_size

        self._load_data()

        if train_classes is None and validate_classes is None and test_classes is None:
            rand = Random()
            rand.seed(1337)
            classes = list(self.__data.keys())
            rand.shuffle(classes)
            train_classes_count = int(0.8 * len(classes))
            train_classes = classes[:train_classes_count]
            validate_classes = classes[train_classes_count:]
            test_classes = classes[train_classes_count:]
        if test_classes is not None and validate_classes is not None:
            classes = list(self.__data.keys())
            train_classes = set(classes)
            train_classes -= set(test_classes)
            train_classes -= set(validate_classes)
            train_classes = list(train_classes)

        super().__init__(
            train_classes=train_classes, validate_classes=validate_classes, test_classes=test_classes,
            auto_load_data=True, return_1d_images=return_1d_audio_data, min_cluster_count=min_cluster_count,
            max_cluster_count=max_cluster_count,
            min_element_count_per_cluster=minimum_snippets_per_cluster if isinstance(minimum_snippets_per_cluster, int) else len(minimum_snippets_per_cluster)
        )

    def _get_img_data_shape(self):

        # If "return_equal_snippet_size" is False, then just an upper-bound is returned
        return (self.__output_length, self.__audio_helper.get_default_spectrogram_coefficients_count(), 1)

    def __get_cache_key(self, path):
        return "[{}]_[{}]".format(self.__audio_helper.get_settings_str(), path)

    def __load_audio_file(self, path):
        cache_key = self.__get_cache_key(path)
        if self.__cache is not None and self.__cache.exists(cache_key):
            print("Load {} from the cache...".format(path))
            return self.__cache.load(cache_key)
        print("Load {}...".format(path))
        content = self.__audio_helper.audio_to_default_spectrogram(path)
        content = np.transpose(content)
        content = np.reshape(content, content.shape + (1,))
        if self.__cache is not None:
            self.__cache.save(cache_key, content)
        return content

    def _load_data(self):
        if self.__data is None:
            clusters = self._get_audio_file_clusters(self.__data_dir)
            output_clusters = {}
            t_start = time()
            min_snippet_length = max(map(lambda r: r[0], self.__window_width))
            for k in clusters.keys():

                # Get all audio snippets
                snippets = map(
                    lambda file: {
                        'content': self.__load_audio_file(path.join(self.__data_dir, file)),
                        'filename': path.splitext(path.basename(path.join(self.__data_dir, file)))[0]
                    },
                    sorted(clusters[k])
                )

                # If required: Merge all snippets
                if self.__concat_audio_files_of_speaker:
                    snippets = [{
                        'content': np.concatenate(list(map(lambda x: x['content'], snippets))),
                        'filename': 'CONCAT'
                    }]

                # Filter the snippets for the minimum length
                snippets = list(filter(
                    lambda snippet: snippet['content'].shape[0] >= min_snippet_length,
                    snippets
                ))

                if len(snippets) == 0:
                    print("WARNING: All input files for the class '{}' are to short (the length must be 1s or more). This class is ignored.".format(k))
                else:
                    output_clusters[k] = snippets
            t_end = time()
            t_delta = t_end - t_start
            print("Required {} seconds to load the data...".format(t_delta))
            self.__data = output_clusters
        return self.__data

    def _get_audio_file_clusters(self, data_dir):
        return {}

    def _get_random_element(self, class_name, element_index=None):#, window_range=None, blocked_ranges=None):

        # Get a target audio object
        audio_object = self.__rand.choice(self._get_data()[class_name])
        audio_content = audio_object['content']
        audio_width = audio_content.shape[0]

        # Get all non-blocked ranges (this results in a list of ranges)
        # if blocked_ranges is None:
        #     ranges = [(0, audio_width)]
        # else:
        #     pass

        # Choose a possible window width
        # if window_range is None:
        if (not isinstance(self.__minimum_snippets_per_cluster, int)) and element_index < len(self.__minimum_snippets_per_cluster):
            window_range = self.__minimum_snippets_per_cluster[element_index]
        else:
            possible_window_ranges = list(filter(lambda w: (w[1] - w[0]) <= audio_width, self.__window_width))
            window_range = self.__rand.choice(possible_window_ranges)

        if window_range[0] > audio_width:
            raise Exception("Invalid window width (audio is too short)")
        window_range = (window_range[0], min(window_range[1], audio_width))
        window_width = self.__rand.randint(*window_range)

        # Select a random snippet
        start_index_range = (0, audio_content.shape[0] - window_width)
        start_index = self.__rand.randint(start_index_range[0], start_index_range[1])

        element = audio_content[start_index:(start_index + window_width)]
        additional_obj_info = {
            'description': '{} [{}] [{}-{}]'.format(class_name, audio_object['filename'], start_index, start_index + window_width),
            'class': class_name,
            'sort_key': '{}/{}'.format(class_name, start_index)
        }

        # It may be required to put the element to a larger array (if uniform length elements are required)
        if self.__return_equal_snippet_size:
            output_length = self.__output_length
            element_length = element.shape[0]
            if element_length != output_length:
                result = np.zeros((output_length,) + element.shape[1:], dtype=np.float32)
                start_index = self.__rand.randint(0, output_length - element_length)
                result[start_index:(start_index + element_length)] = element
                element = result

        return element, additional_obj_info

    def _image_plot_preprocessor(self, img):

        # Sometimes the range is not exactly [0, 1]; fix this
        img = np.minimum(img, 1.)
        img = np.maximum(img, 0.)

        # Swap the first two axes
        return img.swapaxes(0, 1)



